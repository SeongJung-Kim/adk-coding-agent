# ADK Coding Test Generator Agent

이 프로젝트는 Google Agent Development Kit(ADK)를 활용하여 코딩 테스트 문제를 자동으로 생성, 검증, 해결하고 테스트 케이스까지 만들어주는 AI 에이전트 시스템입니다.

[깃허브 소스](https://github.com/SeongJung-Kim/adk-codingtest-gen-agent)

![아키텍처 다이어그램](https://raw.githubusercontent.com/jeyong-shin/adk-codingtest-gen-agent/main/architecture.png)


## 프로젝트 구조

```
.
├── coding-agent/
│   ├── agent.py                       # 메인 에이전트 정의
│   ├── prompts.py                     # 메인 에이전트 프롬프트
│   ├── .env.example                   # 환경 변수 예시 파일
│   ├── constants/
│   │   └── constants.py               # 공통 상수 정의
│   └── sub_agents/                    # 하위 에이전트들
│       ├── problem_critic/            # 문제 검토 에이전트
│       │   ├── agents.py
│       │   └── prompts.py
│       ├── problem_generator/         # 문제 생성 에이전트
│       │   ├── agents.py
│       │   └── prompts.py
│       ├── problem_loop/              # 문제 생성 루프 관리 에이전트
│       │   ├── agents.py
│       │   └── prompts.py
│       ├── problem_quality_checker/   # 문제 품질 검사 에이전트
│       │   ├── agents.py
│       │   └── prompts.py
│       ├── problem_solver/            # 문제 해결 에이전트
│       │   ├── agents.py
│       │   └── prompts.py
│       ├── test_case_generator/       # 테스트 케이스 생성 에이전트
│       │   ├── agents.py
│       │   └── prompts.py
│       └── topic_finder/              # 문제 주제 탐색 에이전트
│           ├── agents.py
│           └── prompts.py
├── .gitignore                         # Git 무시 파일 설정
├── README.md                          # 프로젝트 설명 문서
├── requirements.txt                   # 필요 패키지 목록
├── LICENSE                            # 라이센스
└── architecture.png                   # 에이전트 구조 다이어그램
```

## 에이전트 아키텍처

이 프로젝트는 하나의 메인 에이전트와 7개의 하위 에이전트로 구성됩니다:

1. **메인 에이전트**: 전체 프로세스를 관리하고 하위 에이전트들을 조정합니다.

2. **Topic Finder**: 코딩 테스트 문제의 주제를 제안하고 선택합니다.

3. **Problem Loop**: 문제 생성 프로세스를 관리하며 다음 세 에이전트를 반복적으로 활용합니다:
   - **Problem Generator**: 지정된 주제에 맞는 코딩 테스트 문제를 생성합니다.
   - **Problem Critic**: 생성된 문제의 품질을 비판적으로 검토합니다.
   - **Problem Quality Checker**: 비판 결과를 바탕으로 문제의 합격/불합격 여부를 결정합니다.

4. **Problem Solver**: 합격된 문제에 대한 해답을 Java, JavaScript, Python으로 제공합니다.

5. **Test Case Generator**: 문제 검증을 위한 테스트 케이스 생성 Python 스크립트를 작성합니다.

## 설치 및 실행 방법

### 필수 요구사항
- Python 3.9 이상 (3.12 설정)
- Google API 키
- OpenAI API 키

### 설치 단계

1. 저장소 복제
   ```bash
   git clone https://github.com/SeongJung-Kim/adk-coding-agent.git
   cd adk-codingtest-gen-agent
   ```

2. 가상 환경 설정
   ```bash
   python -m venv venv
   ```

3. 가상 환경 활성화
   - Linux/MacOS:
     ```bash
     source venv/bin/activate
     ```
   - Windows:
     ```bash
     .\venv\Scripts\Activate.bat
     ```

4. 필요한 패키지 설치
   ```bash
   pip install -r requirements.txt
   ```

5. 환경 변수 설정
   ```bash
   cp codingtest-generator/.env.example codingtest-generator/.env
   ```
   `.env` 파일을 편집하여 필요한 API 키와 설정을 입력하세요.

6. ADK 웹 서버 실행
   ```bash
   adk web
   ```

## 사용 방법

1. 브라우저에서 `http://localhost:8000`(또는 ADK가 표시하는 URL)에 접속합니다.
2. 에이전트와 대화를 시작하고 코딩 테스트 문제 생성을 요청합니다.
3. 에이전트는 다음과 같은 과정을 통해 코딩 테스트 문제를 생성합니다:
   - 적절한 주제 제안 및 선택
   - 문제 생성, 비판, 품질 검사의 반복 과정
   - 합격된 문제에 대한 다양한 언어로의 해답 제공
   - 테스트 케이스 생성 스크립트 제공


   - BFS 문제를 내고 싶어

![테스트 화면](https://raw.githubusercontent.com/SeongJung-Kim/adk-coding-agent/main/coding-agent-test-result.png)

```
문제1. 바이러스 감염 경로 추적
난이도: 중
유형: 그래프, BFS
문제
세계적인 보안 회사 '바이로스캔(Veroscan)'은 최근 특정 도시에 퍼진 신종 컴퓨터 바이러스의 감염 경로를 추적 중입니다. 각 컴퓨터는 서로 직접 연결되어 있을 수도 있고 아닐 수도 있습니다. 특히, 한 대의 컴퓨터에 바이러스가 침투할 경우, 바이러스는 직접 연결된 컴퓨터를 통해 빠르게 퍼져나갑니다.

감염의 시작점이 된 컴퓨터와, 각 컴퓨터 간의 직접 연결 정보가 주어집니다. 감염이 시작된 이후로, 바이러스가 네트워크를 타고 얼마나 많은 컴퓨터에 감염되는지 조사하고자 합니다. 직접 연결이 여러 단계에 걸쳐 이어질 수 있으니, 직접 또는 간접적으로 감염될 수 있는 컴퓨터의 총 개수를 구하세요. 단, 감염이 시작된 컴퓨터는 총합에서 제외합니다.

보안팀을 도와 감염된 총 컴퓨터의 수를 구하는 프로그램을 작성하세요.

입력 조건
computers: int, 네트워크에 존재하는 컴퓨터 수 (2 ≤ computers ≤ 100)
network: list[list[int]], 연결 정보를 담고 있는 2차원 배열 (network[i][j] == 1이면 i번 컴퓨터와 j번 컴퓨터가 직접 연결되어 있음, 0이면 연결되어 있지 않음)
start: int, 바이러스의 감염이 시작된 컴퓨터 번호 (0 ≤ start < computers)
출력 조건
직접 또는 간접적으로 감염되는 컴퓨터 개수(감염이 시작된 컴퓨터는 제외).
예시 입출력
입력1
computers = 7
network = [
    [0,1,0,0,0,0,0],
    [1,0,1,1,0,0,0],
    [0,1,0,0,0,0,0],
    [0,1,0,0,0,0,0],
    [0,0,0,0,0,1,1],
    [0,0,0,0,1,0,0],
    [0,0,0,0,1,0,0]
]
start = 0
출력1
3
입력2
computers = 4
network = [
    [0, 1, 0, 0],
    [1, 0, 1, 0],
    [0, 1, 0, 1],
    [0, 0, 1, 0]
]
start = 1
출력2
3
문제 해설
이 문제는 그래프의 연결 요소 탐색을 활용한 대표적인 BFS 문제입니다. 주어진 컴퓨터 네트워크를 무방향 그래프로 보고, 감염이 시작된 컴퓨터에서 BFS(너비 우선 탐색)를 통해 감염이 퍼지는 경로를 모두 추적하면 됩니다. 각 정점을 방문하면서 이미 방문한 컴퓨터를 다시 방문하지 않게 하며, 감염된 컴퓨터 개수를 세어, 시작 컴퓨터를 제외한 총 감염된 컴퓨터 수를 반환합니다.

시간복잡도는 BFS 탐색에 O(N^2)입니다. (여기서 N은 컴퓨터의 수, 2차원 인접 행렬이기 때문)
문제평가 점수: 8 / 10

평가 및 상세 설명
장점:

문제의 목적과 상황이 명확하게 제시되어 있어 수험자가 혼란없이 문제에 접근할 수 있음.
인접 행렬 형태의 입력으로 BFS를 연습하기에 좋고, 감염의 시작점 등 현실적인 상황을 반영해 몰입도를 높임.
예제 입력/출력이 구체적으로 제공되어 입출력 형식이 명확함.
BFS(혹은 DFS 포함) 그래프 탐색의 기초를 확인하기 적합.
데이터 범위(2~100)가 과하지 않고, 복잡도 고려에서 적절.
단점 및 아쉬운 점:

고정 입력 형식: ‘network’가 입력으로 2차원 리스트로 고정되어 있는데, 실제 코딩테스트 환경에서는 입력 파싱이 직접적으로 중요한데 이를 생략한 점이 아쉬움(즉, 파이썬 스타일의 raw input에서 파싱해야 더 좋음).
반복/유사 문제 많음: 이 문제 유형은 워낙 기출이 많아 신선도가 부족함(‘바이러스’ 문제는 백준 등에서 매우 많이 출제).
테스트 케이스 다양성 부족: 예시가 연결 그래프만 제시. ‘시작 컴퓨터와 연결된 컴퓨터가 없음’(출력 0), ‘모두 한 덩어리’ 케이스 등이 누락됨.
추가 조건 혹은 변별 포인트 부족: 예를 들어, 연결이 방향성이 있다거나, 감염 속도(최단 시간 계산), 연결 단가 등 추가 요소가 없다면 변별력이 부족할 수 있음.
감염 시작 컴퓨터의 인덱스 처리 명확성: 0-indexed, 1-indexed 혼용이 빈번한데, 파라미터 설명에서는 명확하나 입출력 예시 및 설명에서 ‘컴퓨터 번호’에 대한 주의가 (추가) 강조되면 더 안전.
개선 제안
입력 포맷 명확화 및 현실 반영

표준 입력에서 n, 바로 아래 m줄에 연결 쌍을 주는 등, 직접적인 파싱 과정이 문제에 포함되면 실력을 더 명확히 드러낼 수 있음.
문제 신선도 & 변별력 보강

감염되는 데 걸리는 최소 시간(최단 거리)에 따른 ‘몇 초 후 감염된 컴퓨터 수’를 묻거나,
네트워크가 방향 그래프(방화벽 등 조건 고려)가 되어야만 감염이 된다 등 추가 조건을 붙이면 더 흥미로울 것.
테스트 케이스 보강

연결 그래프가 아니어서 감염이 전혀 확산되지 않는 경우,
여러 개의 컴포넌트 중 일부만 감염되는 경우,
모든 컴퓨터가 하나의 컴포넌트인 경우 등의 예제를 추가 제공.
0-index vs 1-index 강조

인덱스와 실제 컴퓨터 번호의 혼동을 방지하기 위해, 문제 예시에서 인덱스와 컴퓨터 번호가 동일함을 추가 설명.
시간복잡도 언급 수정

현실적으로 인접 리스트로 표현하면 O(V+E)라 할 수 있으니, 인접 행렬로 제한하는 배경 설명이 들어가면 더 친절함.
결론
기본기의 확인엔 충분한 문제이나, 신선함·변별력을 살짝 더할 여지가 있음.
입출력 예시와 입력 포맷 설명이 더 명확해진다면, 실전 코딩테스트 환경 유사도를 더 높일 수 있음.
총평: 연습문제로 적합하되, 대회나 기업 코딩테스트라면 한두 가지 변형/조건을 추가하거나, 입출력 포맷, 테스트케이스 다양성 부분을 조금 더 보강하면 좋겠습니다.
```


## 라이선스

이 프로젝트는 MIT 라이선스 하에 배포됩니다. 자세한 내용은 [LICENSE](LICENSE) 파일을 참조하세요.